<div class="chart-figure">
  {#if title}
    <div class="label { noLabel ? 'sr-only' : '' }">{ title }</div>
  {/if}

  <figure aria-labelledby="label-{ id }">
    <div class="chart chart-histogram" ref:chart role="img" title="{ title }"
      bind:clientWidth="containerWidth" bind:clientHeight="containerHeight">
      <svg viewbox="0 0 { containerWidth } { containerHeight }" width="{ containerWidth }" height="{ containerHeight }" preserveaspectratio="xMidYMid meet">
        <g class="chart-area" transform="translate({ padding.left }, { padding.top })">
          <g class="axis x-axis">
            {#if xTicks}
              {#each xTicks as tick, i}
                <g class="tick tick-{ i }" transform="translate({ xScale(tick) }, { yScale.range()[0] })">
                  <line class="grid-line" y1="{ chartHeight * -1 }" y2="0" x1="0" x2="0"></line>
                  <text y="5" text-anchor="middle">{ xTickFormat ? xTickFormat(tick, i, xTicks.length) : tick }</text>
                </g>
              {/each}
            {/if}

            {#if xBaseline}
              <line class="baseline" y1="{ chartHeight + 0.5 }" y2="{ chartHeight + 0.5}" x1="0" x2="{ chartWidth }"></line>
            {/if}
          </g>

          <g class="axis y-axis">
            {#if yTicks}
              {#each yTicks as tick, i}
                <g class="tick tick-{ i }" transform="translate(0, { yScale(tick) })">
                  <line x2="{ chartWidth }"></line>

                  <text y="-3" x="3" text-anchor="start">{ yTickFormat ? yTickFormat(tick, i, xTicks.length) : tick }</text>
                </g>
              {/each}
            {/if}

            {#if yBaseline}
              <line class="baseline" y1="0" y2="{ chartHeight }" x1="0" x2="0"></line>
            {/if}
          </g>

          <g class="histogram-bars">
            {#each data as d, i}
              {#if d.count}
                <rect class="histogram-bar"
                  x="{ xScale(d.min) }"
                  y="{ Math.min(yScale(d.count), yScale(yMax * 0.01)) }"
                  width="{ xScale(d.max) - xScale(d.min) }"
                  height="{ chartHeight - (Math.min(yScale(d.count), yScale(yMax * 0.01))) }"
                ></rect>
              {/if}
            {:else}
              <!-- -->
            {/each}
          </g>

          {#if annotationLines}
            <g class="annotation-lines">
              {#each annotationLines as a, i}
                <line class="annotation-line annotation-line-{ i }"
                  x1="{ xScale(a) }"
                  y1="{ 0 }"
                  x2="{ xScale(a) }"
                  y2="{ chartHeight }"></line>
              {/each}
            </g>
          {/if}
        </g>
      </svg>
    </div>

    <figcaption class="figcaption-bottom { noCaption ? 'sr-only' : '' }">
      <slot></slot>
    </figcaption>
  </figure>
</div>


<script>
  import { isNaN } from "lodash";
  import { scaleLinear } from "d3-scale";

  /* global d3, c3 */
  export default {
    oncreate() {
      let { xMin, xMax, yMin, yMax, chartWidth, chartHeight } = this.get();

      this.set({
        xScale: scaleLinear()
          .domain([xMin, xMax])
          .range([0, chartWidth]),
        yScale: scaleLinear()
          .domain([yMin, yMax])
          .range([chartHeight, 0])
      });
    },

    computed: {
      chartWidth({ containerWidth, padding, defaultWidth }) {
        return containerWidth
          ? containerWidth - padding.left - padding.right
          : defaultWidth;
      },

      chartHeight({ containerHeight, padding, defaultHeight }) {
        return containerHeight
          ? containerHeight - padding.top - padding.bottom
          : defaultHeight;
      },

      xScale({ scaleLinear, xMin, xMax, chartWidth }) {
        return scaleLinear()
          .domain([xMin, xMax])
          .range([0, chartWidth]);
      },

      yScale({ scaleLinear, yMin, yMax, chartHeight }) {
        return scaleLinear()
          .domain([yMin, yMax])
          .range([chartHeight, 0]);
      },

      xTicks({ xTickCount, xScale }) {
        return xScale && xScale.ticks ? xScale.ticks(xTickCount) : undefined;
      },

      yTicks({ yTickCount, yScale }) {
        return yScale && yScale.ticks ? yScale.ticks(yTickCount) : undefined;
      }
    },

    data() {
      return {
        defaultWidth: 400,
        defaultHeight: 300,
        padding: { top: 10, right: 20, bottom: 25, left: 10 },
        xMin: 0,
        xMax: 1,
        yMin: 0,
        yMax: 100,
        xTickCount: 10,
        yTickCount: 10,
        xBaseline: true,
        xTickFormat: (t, i, len) =>
          `${Math.round(t * 100)}${i === len - 1 ? "%" : ""}`,
        yTickFormat: (t, i, len) => `${t ? t.toLocaleString() : ""}`,
        xScale: i => i,
        yScale: i => i,
        scaleLinear
      };
    }
  };
</script>


